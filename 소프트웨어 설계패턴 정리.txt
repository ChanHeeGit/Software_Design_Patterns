<1장 스트래티지 패턴>

정의 : 알고리즘을 정의하고 각각을 캡슐화하여 교환해서 사용 가능하게 함
디자인 원칙 : 변화하는 부분과 변하지 않는 부분을 분리하라.
                 구현이 아닌 인터페이스에 맞춰 프로그래밍하라. 
                 상속보다는 구구성을 활용하라(상속은 확장성에 문제가 있음)
1. 상속&오버라이딩 사용
장점 : 공통된 것은 쉽게 재사용이 가능
        새로운 오리를 추가하는 것이 용이하다.  
        오리의 행동을 구분하기가 쉽다.
단점 : 공통되지 않는 메소드가 추가될 시 서브클래스에 영향을 미친다.
        Duck 클래스의 변경이 서브 클래스에게 영향을 미친다(가장 큰 문제점)
        Duck 서브클래스에서 코드가 중복될 수 있다.
        Duck 서브클래스의 정의만 보고는 행동 차이를 구분하기 힘들 수 있다.
        
2. 인터페이스 사용
장점 : 공통된 행동들의 재사용이 용이함.
        새로운 종류의 오리를 추가하는 것이 용이하다. 
        Duck의 서브클래스만 보고도 행동 구분이 가능
단점 : 인터페이스로 구현되었기 때문에 코드의 재사용이 불가
        공통행동의 변화 시(Duck 클래스) 서브클래스에 영향을 미친다.

3. 독립적인 인터페이스 구현
장점 : 독립적으로 구현된 인터페이스 안의 메소드를 구현하는 오리들의
        추가가 용이하다.
단점 : 오리의 행동이 fly->rocket과 같이 변경되었을 때 서브클래스의 변경 필요

훌륭한 객체지향 디자인 3가지 : 재사용성, 확장성, 관리의 용이성

<2장 옵저버 패턴>

정의 : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고,
        자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의
        스윙 및 여러 GUI 프레임워크에서 많이 쓰임
디자인 원칙 : 서로 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 사용
                 상호작용하는 두 객체가 서로의 구현은 모르고 추상화된 인터페이스만을
                 알고 있음을 의미함.

setChanged() 메소드
1. Observable 객체의 상태가 변경됨을 알리기 위해 호출됌
2. 무조건 notifyObservers() 메소드 전에 호출되어야 함
3. Observable 객체의 changed 속성 값을 변경시킴(true, false)

java.util.Observable 클래스
->다른 클래스에 기능 확장 불가
->Observable의 메소드 setChanged()는 외부에서 호출할 수 없음

push 방식 : 변경을 통지하고 동시에 데이터를 전송하는 방식
장점 : 변경사항을 바로 알 수 있다.
단점 : 데이터가 너무 크면 클래스가 통지를 했을 시 전송되는 시간이 매우 느림
        정보가 추가되면 기존 인터페이스를 전부 수정해 줘야 함
pull 방식 : 클래스가 변경을 통지하면 옵저버가 정보를 가져가는 방식
장점 : 데이터가 큰 경우에 push 방식보다 유리하다.
        정보가 추가되도 필요로 하는 부분만 수정해줘도 됌
단점 : 클래스로부터 통지를 받으면 옵저버가 다시 클래스에서 정보를 가져와야 함
->notiftObservers(null)

<3장 데코레이터 패턴>

정의 : 객체에 추가적인 요건을 동적으로 첨가
        서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공

정리 : 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
        한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
        데코레이터는 자신이 장식하고 있는 객체에게 추가적인 작업이 가능하다.
        실행 중에도 데코레이터를 적용할 수 있다.(구성과 위임을 통함)
        감싸는 구성요소를 정확하게 알지 못한다!!
        구성요소의 구체적인 형식에 의존하게 되는 경우는 해당 패턴 사용 불가 
        데코레이터에서는 구상 구성요소(Concrete Component)를 감싸주는 데코레이터들을 사용

디자인 원칙 : 클래스는 확장에 대해서는 열려 있어야 하지만
                 코드 변경에 대해서는 닫혀 있어야 한다.(확장을 통한 새로운 행동 추가)

<4장 팩토리 패턴>

1. 간단한 팩토리
->자주 쓰이는 관용구에 가까움
->정적 메소드로 선언하는 경우가 많음
->간단한 팩토리를 사용하는 클래스가 많은 경우, 구현을 변경해야 한다면
   변경 부분을 이 클래스로 한정시킬 수 있음
pizza 클래스에서 prepare, bake, cut, box 등의 공통 메서드를 구현해놓고
PizzaStore 추상클래스에서 구현함
->createPizze(type) : 확장될 수 있는 부분
PizzaTestDrive 클래스
PizzaStore nyStore = new NYPizzaStore();
Pizza pizza = nyStore.orderPizza("cheese);

2. 팩토리 메소드 패턴
정의 : 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를
        만들지는 서브클래스에서 결정함
        팩토리 메소드는 객체 생성을 처리하며, 이 패턴을 이용하면 클래스의 인스턴스
        만드는 일은 서브클래스가 하게 됌
디자인 원칙 : 의존성 뒤집기, 구상 클래스에 의존하지 말고 추상화된 것에 의존하라
                 고수준 구성요소가 저수준 구성요소에 의존하도록 하면 안된다.
                 고수준 저수준 상관없이 서로 의존하면 안되고 추상화된 것에 의존해야 함
                 -> 인터페이스에 의존, 추상 클래스에 의존

3. 추상 팩토리 패턴
정의 : 인터페이스를 이용하여 서로 연관되거나 의존하는 객체를 구상 클래스를 
        지정하지 않고도 생성할 수 있다.
장점 : 많은 수의 연관된 제품들의 생성을 한번에 교체 가능
단점 : 생성시킬 제품이 추가되는 경우 팩토리도 새로 만들어야 하고 그것을 구현하는 
        클래스도 만들고.. 추가되는 게 많아진다.

정리 : 팩토리 메소드 패턴에서는 상속을 활용, 추상 팩토리 패턴에서는 객체 구성을 활용
        느슨한 결합, 의존성 뒤집기 원칙에 의해 추상화를 지향
        -> 구상 클래스가 아닌 추상 클래스나 인터페이스에 맞춰서 코딩할 수 있게 함

<5장 싱글턴 패턴>

정의 : 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 
        있도록 하기 위한 패턴
사용ex : 스레드 풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록용 객체, 디바이스 드라이버

스레드가 2개 이상 실행 시 객체가 2개 이상 만들어 질 수가 있다
해결방법 3가지
1. Synchronized 사용
public static synchronized Chocolate ....()
메소드 시작 때 동기화 이후에는 오버헤드를 발생시킴(성능 100배저하)
2. 클래스 로딩시 각체 생성
미리 만들어져 있기 때문에 사용되기 전부터 메모리를 차지하고 있게 됌
3. Doublc-Checking Locking
가장 효율적인 방법으로 if문을 2번 사용한다.
if unique==null 일 때만 객체를 생성하게 한다.
private volatile <- unique의 변경이 다중 스레드에게 올바르게 보이도록 보장해줌
-> 객체가 생성되었다는걸 보여줌

정리 : 싱글턴 패턴을 적용하면 클래스의 인스턴스가 최대 한 개만 있게 함
        유일한 인스턴스는 어디에서든지 접근 가능함
        싱글턴 패턴 구현 시 private 생성자, 정적 메소드, 정적 변수 3가지를 사용!!
       
<6장 커맨드 패턴>

정의 : 요구사항을 객체로 캡슐화할 수 있다.
        요청 내역을 큐에 저장, 로그로 기록 가능, 작업 취소 기능을 지원

스택을 이용한 undo 구현 가능
ex)
undoCommand.push(onCommands[slot]);
undoCommand.pop().undo();

정리 : excute() 메소드는 Receiver의 Action을 호출한다.
        작업 취소 기능, 로그, 트랜잭션 시스템 구현 가능
        앱 커맨드 실행에 대한 내용 로그로 기록 가능, 상태에 대한 것은 기록 불가능!!



